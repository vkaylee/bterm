<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>BTerminal</title>
    <script src="./assets/tailwindcss.js"></script>
    <link rel="stylesheet" href="./assets/xterm.css" />
    <script src="./assets/xterm.js"></script>
    <script src="./assets/xterm-addon-fit.js"></script>
    <script src="./assets/xterm-addon-webgl.js"></script>
    <script src="./assets/xterm-addon-canvas.js"></script>
    <style>
        @font-face {
            font-family: 'JetBrains Mono';
            src: url('./assets/fonts/JetBrainsMono-Regular.ttf') format('truetype');
        }
        body { 
            background-color: #020617; 
            color: white; 
            margin: 0;
            font-family: 'JetBrains Mono', monospace;
        }
        .xterm-viewport { overflow-y: auto !important; }
        .xterm-screen { touch-action: manipulation !important; }
        #terminal { 
            background-color: black; 
            will-change: transform;
            backface-visibility: hidden;
            touch-action: manipulation;
            margin: auto; /* Căn giữa terminal khi buffer nhỏ hơn container */
            display: block;
        }
        #terminal-view {
            overflow: auto; /* Cho phép scroll khi terminal buffer lớn hơn màn hình */
            background-color: #000;
            width: 100%;
            height: 100%;
            -webkit-overflow-scrolling: touch;
        }
        /* Style cho các nút điều khiển trên mobile */
        .btn-ctrl {
            background-color: #334155;
            padding: 10px 4px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 700;
            text-align: center;
            color: #f1f5f9;
            transition: all 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
            text-transform: uppercase;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        .btn-ctrl:active { 
            background-color: #3b82f6; 
            transform: scale(0.95);
        }
    </style>
</head>
<body class="overflow-hidden">
    <div id="app" class="flex flex-col h-[100dvh] w-screen">
        <!-- Header -->
        <header class="flex justify-between items-center px-4 py-2.5 bg-slate-900 border-b border-slate-800 shadow-md z-10">
            <div class="flex items-center gap-4">
                <div class="flex items-center gap-2">
                    <div class="w-8 h-8 bg-blue-600 rounded-lg flex items-center justify-center shadow-lg shadow-blue-900/20">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 9l3 3-3 3m5 0h3M5 20h14a2 2 0 002-2V6a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" />
                        </svg>
                    </div>
                    <h1 class="text-lg font-bold text-white tracking-tight hidden sm:block">BTerminal</h1>
                </div>
                
                <div id="session-info" class="hidden items-center gap-2 bg-slate-800/50 px-3 py-1.5 rounded-full border border-slate-700/50">
                    <div class="w-2 h-2 bg-green-500 rounded-full animate-pulse shadow-[0_0_8px_rgba(34,197,94,0.6)]"></div>
                    <span class="text-gray-400 text-xs font-medium uppercase tracking-wider">Active:</span>
                    <span id="current-session-id" class="text-blue-400 text-sm font-bold font-mono"></span>
                    <button onclick="backToDashboard()" class="ml-2 p-1 text-gray-400 hover:text-red-400 transition" title="Exit Session">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" />
                        </svg>
                    </button>
                </div>
            </div>
            <div class="flex items-center gap-3">
                <div class="flex flex-col items-end">
                    <span class="text-[10px] text-gray-500 font-bold uppercase tracking-widest leading-none">Status</span>
                    <span class="text-[10px] text-green-500 font-medium leading-none mt-1">System Online</span>
                </div>
            </div>
        </header>

        <!-- Dashboard -->
        <main id="dashboard" class="flex-1 overflow-y-auto p-4 md:p-8 bg-slate-950">
            <div class="max-w-4xl mx-auto flex flex-col gap-8">
                <!-- Active Sessions Section -->
                <section id="active-sessions-section" style="display: none">
                    <div class="flex justify-between items-center mb-6 px-2">
                        <h2 class="text-xl font-bold text-white">Active Sessions</h2>
                        <span id="session-count" class="bg-slate-800 text-slate-400 text-xs px-2.5 py-1 rounded-full border border-slate-700">0 Total</span>
                    </div>
                    <div id="session-list" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 mb-10">
                        <!-- Sessions list populated via JS -->
                    </div>
                </section>

                <!-- Create New Session Section (Moved Down) -->
                <section class="bg-slate-900/50 p-6 rounded-2xl border border-slate-800/50 backdrop-blur-sm">
                    <div class="flex flex-col gap-6">
                        <div>
                            <h2 class="text-lg font-bold text-white mb-1">Start a New Instance</h2>
                            <p class="text-slate-500 text-sm">Create a unique session ID to begin a new terminal workspace.</p>
                        </div>
                        <div class="flex flex-col gap-3 sm:flex-row">
                            <input type="text" id="new-session-name" placeholder="E.g. production-logs, dev-server..." 
                                   onfocus="this.scrollIntoView({ behavior: 'smooth', block: 'center' })"
                                   onkeydown="if(event.key === 'Enter') createSession()"
                                   class="bg-slate-950 border border-slate-700 rounded-xl px-4 py-3 flex-1 focus:outline-none focus:ring-2 focus:ring-blue-500/50 transition text-gray-200 placeholder:text-slate-600">
                            <button onclick="createSession()" class="bg-blue-600 hover:bg-blue-700 text-white px-8 py-3 rounded-xl font-bold transition shadow-lg shadow-blue-900/20 flex items-center justify-center gap-2 group">
                                <span>Create Session</span>
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 group-hover:translate-x-1 transition-transform" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7l5 5m0 0l-5 5m5-5H6" />
                                </svg>
                            </button>
                        </div>
                    </div>
                </section>
            </div>
        </main>

        <!-- Terminal View -->
        <div id="terminal-view" class="hidden flex-1 flex-col bg-black relative w-full overflow-auto">
            <div id="terminal" class="flex-1 w-full h-full overflow-hidden"></div>
            
            <!-- Mobile Controls -->
            <div id="control-bar" class="hidden flex-col gap-1 p-1.5 bg-slate-900 border-t border-slate-800 shadow-[0_-4px_10px_rgba(0,0,0,0.3)]">
                <!-- Hàng trên -->
                <div class="grid grid-cols-7 gap-1">
                    <button class="btn-ctrl" onmousedown="event.preventDefault()" onclick="sendSpecialKey('escape')">Esc</button>
                    <button class="btn-ctrl" onmousedown="event.preventDefault()" onclick="sendSpecialKey('slash')">/</button>
                    <button class="btn-ctrl" onmousedown="event.preventDefault()" onclick="sendSpecialKey('minus')">-</button>
                    <button class="btn-ctrl" onmousedown="event.preventDefault()" onclick="sendSpecialKey('home')">Home</button>
                    <button class="btn-ctrl" onmousedown="event.preventDefault()" onclick="sendSpecialKey('arrowup')">▲</button>
                    <button class="btn-ctrl" onmousedown="event.preventDefault()" onclick="sendSpecialKey('end')">End</button>
                    <button class="btn-ctrl" onmousedown="event.preventDefault()" onclick="sendSpecialKey('pageup')">PgUp</button>
                </div>
                
                <!-- Hàng dưới -->
                <div class="grid grid-cols-7 gap-1">
                    <button class="btn-ctrl" onmousedown="event.preventDefault()" onclick="sendSpecialKey('tab')">Tab</button>
                    <button id="btn-ctrl-key" class="btn-ctrl" onmousedown="event.preventDefault()" onclick="sendSpecialKey('control')">Ctrl</button>
                    <button id="btn-alt-key" class="btn-ctrl" onmousedown="event.preventDefault()" onclick="sendSpecialKey('alt')">Alt</button>
                    <button class="btn-ctrl" onmousedown="event.preventDefault()" onclick="sendSpecialKey('arrowleft')">◀</button>
                    <button class="btn-ctrl" onmousedown="event.preventDefault()" onclick="sendSpecialKey('arrowdown')">▼</button>
                    <button class="btn-ctrl" onmousedown="event.preventDefault()" onclick="sendSpecialKey('arrowright')">▶</button>
                    <button class="btn-ctrl" onmousedown="event.preventDefault()" onclick="sendSpecialKey('pagedown')">PgDn</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let term, fitAddon, ws;
        let ctrlActive = false;
        let altActive = false;

        // Expose to window for E2E tests
        window.term = null;
        window.fitAddon = null;
        window.ws = null;

        let isSyncingSize = false;
        const resizeObserver = new ResizeObserver(() => {
            if (term && fitAddon && !isSyncingSize && document.getElementById('terminal-view').style.display === 'flex') {
                requestAnimationFrame(() => {
                    try {
                        const dims = fitAddon.proposeDimensions();
                        if (dims && ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({ type: 'Resize', data: { rows: dims.rows, cols: dims.cols } }));
                        }
                    } catch (e) {}
                });
            }
        });

        // Xử lý VisualViewport để đẩy các phím ảo lên khi bàn phím mobile xuất hiện
        let updateTick = false;
        function throttledUpdate() {
            if (!updateTick) {
                requestAnimationFrame(() => {
                    updateVisualViewport();
                    updateTick = false;
                });
                updateTick = true;
            }
        }

        function updateVisualViewport() {
            const viewport = window.visualViewport;
            const controlBar = document.getElementById('control-bar');
            const terminalView = document.getElementById('terminal-view');
            const dashboard = document.getElementById('dashboard');
            const app = document.getElementById('app');
            
            if (!viewport || !app) return;

            // Luôn cập nhật chiều cao app theo viewport thực tế (giúp tránh bị che bởi keyboard/toolbars)
            app.style.height = `${viewport.height}px`;

            if (terminalView.style.display === 'flex' && controlBar) {
                // Tính toán khoảng cách bị che khuất bởi bàn phím
                const offset = window.innerHeight - viewport.height - viewport.offsetTop;
                
                // Nếu offset > một ngưỡng nhỏ (ví dụ 50px), coi như bàn phím đang hiện
                const isKeyboardVisible = offset > 50;

                if (isKeyboardVisible) {
                    controlBar.style.display = 'flex';
                } else {
                    controlBar.style.display = 'none';
                }
                
                // Đảm bảo terminal được fit lại và cuộn tới cuối
                if (term && fitAddon && !isSyncingSize) {
                    try { 
                        const dims = fitAddon.proposeDimensions();
                        term.scrollToBottom();
                        if (dims && ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({ type: 'Resize', data: { rows: dims.rows, cols: dims.cols } }));
                        }
                    } catch(e) {}
                }
            } else if (dashboard && !dashboard.classList.contains('hidden')) {
                // Khi ở Dashboard, đảm bảo phần tử focus được nhìn thấy
                if (document.activeElement && document.activeElement.tagName === 'INPUT') {
                    setTimeout(() => {
                        document.activeElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }, 100);
                }
            }
        }

        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', throttledUpdate, { passive: true });
            window.visualViewport.addEventListener('scroll', throttledUpdate, { passive: true });
        }

        async function fetchSessions() {
            try {
                const res = await fetch('/api/sessions');
                const sessions = await res.json();
                const section = document.getElementById('active-sessions-section');
                const list = document.getElementById('session-list');
                const countLabel = document.getElementById('session-count');
                list.innerHTML = '';
                
                if (countLabel) countLabel.innerText = `${sessions.length} Total`;

                if (!sessions || sessions.length === 0) {
                    section.style.display = 'none';
                    // Auto-focus the input if there are no sessions
                    const input = document.getElementById('new-session-name');
                    if (input) input.focus();
                    return;
                }

                section.style.display = 'block';
                sessions.forEach(s => {
                    const card = document.createElement('div');
                    card.className = 'group relative bg-slate-800 p-5 rounded-lg border border-slate-700 hover:border-blue-500 cursor-pointer transition shadow-md';
                    card.onclick = () => joinSession(s.id);
                    card.innerHTML = `
                        <div class="font-mono text-lg font-bold mb-1">${s.id}</div>
                        <div class="text-xs text-gray-500">Connect to session</div>
                        <button onclick="event.stopPropagation(); removeSession('${s.id}')" 
                                class="absolute top-4 right-4 p-2 text-gray-500 hover:text-red-400 opacity-0 group-hover:opacity-100 transition">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                            </svg>
                        </button>
                    `;
                    list.appendChild(card);
                });
            } catch (e) { console.error("Fetch sessions failed", e); }
        }

        async function createSession() {
            const input = document.getElementById('new-session-name');
            const id = input.value.trim();
            if (!id) return;
            
            console.log("Creating session:", id);
            try {
                const res = await fetch('/api/sessions', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ id })
                });
                if (res.ok) {
                    input.value = '';
                    // Automatically join the newly created session
                    joinSession(id);
                } else {
                    alert('Error: Session ID might already exist.');
                }
            } catch (e) {
                console.error("Create session failed", e);
                alert("Network error. Is the server running?");
            }
        }

        async function removeSession(id) {
            if (!confirm(`Are you sure you want to delete session "${id}"?`)) return;
            try {
                const res = await fetch(`/api/sessions/${id}`, { method: 'DELETE' });
                if (res.ok) fetchSessions();
            } catch (e) { console.error(e); }
        }

        function joinSession(id) {
            document.getElementById('dashboard').classList.add('hidden');
            const view = document.getElementById('terminal-view');
            view.style.display = 'flex';
            document.getElementById('session-info').classList.remove('hidden');
            document.getElementById('current-session-id').innerText = id;
            
            if (term) term.dispose();
            const container = document.getElementById('terminal');
            container.innerHTML = '';
            
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 640;
            term = new Terminal({
                cursorBlink: true,
                fontSize: isMobile ? 14 : 15,
                fontFamily: '"JetBrains Mono", monospace',
                theme: { 
                    background: '#000000', 
                    foreground: '#e2e8f0', 
                    cursor: '#ffffff',
                    selectionBackground: 'rgba(255, 255, 255, 0.3)'
                },
                allowProposedApi: true,
                screenReaderMode: false,
                letterSpacing: 0.5,
                lineHeight: 1.2,
                cursorStyle: 'block'
            });
            window.term = term;
            
            fitAddon = new FitAddon.FitAddon();
            window.fitAddon = fitAddon;

            term.loadAddon(fitAddon);
            
            // Multi-tier Renderer Fallback: WebGL -> Canvas -> DOM
            const urlParams = new URLSearchParams(window.location.search);
            const requestedRenderer = urlParams.get('renderer'); // webgl, canvas, dom
            
            const supportsWebgl = () => {
                try {
                    const canvas = document.createElement('canvas');
                    return !!(window.WebGLRenderingContext && (canvas.getContext('webgl') || canvas.getContext('webgl2')));
                } catch (e) { return false; }
            };

            const supportsCanvas = () => {
                try {
                    const canvas = document.createElement('canvas');
                    return !!(canvas.getContext('2d'));
                } catch (e) { return false; }
            };

            const enableWebgl = () => {
                try {
                    const AddonConstructor = (typeof WebglAddon === 'function') ? WebglAddon : WebglAddon.WebglAddon;
                    const addon = new AddonConstructor();
                    addon.onContextLoss(() => {
                        console.warn("WebGL context lost, falling back to Canvas");
                        addon.dispose();
                        enableCanvas();
                    });
                    term.loadAddon(addon);
                    console.log("WebGL renderer enabled");
                    return true;
                } catch (e) {
                    console.warn("WebGL addon failed:", e.message);
                    return false;
                }
            };

            const enableCanvas = () => {
                try {
                    const AddonConstructor = (typeof CanvasAddon === 'function') ? CanvasAddon : CanvasAddon.CanvasAddon;
                    const addon = new AddonConstructor();
                    term.loadAddon(addon);
                    console.log("Canvas renderer enabled");
                    return true;
                } catch (e) {
                    console.warn("Canvas addon failed:", e.message);
                    return false;
                }
            };

            term.open(container);

            // Bridge for Long Press to Selection on Mobile
            let touchTimer;
            let isSelecting = false;
            const LONG_PRESS_DURATION = 500;

            const dispatchMouseEvent = (type, touch) => {
                const screen = container.querySelector('.xterm-screen');
                const target = document.elementFromPoint(touch.clientX, touch.clientY) || screen;
                if (!target) return;
                
                // If the target is not the screen or a child of it, and we have a screen, use the screen
                const finalTarget = (screen && (target === screen || screen.contains(target))) ? target : screen;
                if (!finalTarget) return;

                const ev = new MouseEvent(type, {
                    bubbles: true,
                    cancelable: true,
                    view: window,
                    clientX: touch.clientX,
                    clientY: touch.clientY,
                    button: 0,
                    buttons: type === 'mouseup' ? 0 : 1,
                    detail: type === 'mousedown' ? 1 : 0
                });
                // Legacy property for older event handling
                Object.defineProperty(ev, 'which', { get: () => type === 'mouseup' ? 0 : 1 });
                
                finalTarget.dispatchEvent(ev);
            };

            container.addEventListener('touchstart', (e) => {
                if (e.touches.length !== 1) return;
                const touch = e.touches[0];
                clearTimeout(touchTimer);
                touchTimer = setTimeout(() => {
                    isSelecting = true;
                    dispatchMouseEvent('mousedown', touch);
                    // Provide haptic feedback if available
                    if (window.navigator && window.navigator.vibrate) {
                        window.navigator.vibrate(50);
                    }
                }, LONG_PRESS_DURATION);
            }, { passive: false });

            container.addEventListener('touchmove', (e) => {
                if (isSelecting) {
                    e.preventDefault(); // Stop scrolling when selecting
                    dispatchMouseEvent('mousemove', e.touches[0]);
                } else {
                    // Small threshold for jitter
                    const touch = e.touches[0];
                    // If moving too much, it's a scroll
                    clearTimeout(touchTimer);
                }
            }, { passive: false });

            container.addEventListener('touchend', (e) => {
                clearTimeout(touchTimer);
                if (isSelecting) {
                    dispatchMouseEvent('mouseup', e.changedTouches[0]);
                    isSelecting = false;
                    e.preventDefault();
                }
            }, { passive: false });

            container.addEventListener('touchcancel', () => {
                clearTimeout(touchTimer);
                isSelecting = false;
            });

            // Smart Copy/Paste Handling
            term.attachCustomKeyEventHandler((ev) => {
                // Ctrl+C: Copy if selection exists, else send SIGINT
                if (ev.ctrlKey && ev.type === 'keydown' && (ev.key === 'c' || ev.key === 'C')) {
                    if (term.hasSelection()) {
                        return false; // Let browser handle copy
                    }
                    return true; // Let xterm handle (send \x03)
                }
                
                // Ctrl+V: Paste
                if (ev.ctrlKey && ev.type === 'keydown' && (ev.key === 'v' || ev.key === 'V')) {
                    return false; // Let browser handle paste
                }
                
                return true;
            });

            // Tối ưu hóa cho IME (Vietnamese Telex, v.v.)
            // Flag to track if the user is currently composing text (IME)
            let isComposing = false;

            function waitForTextarea(retries = 10) {
                const textarea = container.querySelector('.xterm-helper-textarea');
                if (textarea) {
                    console.log("IME: Textarea found, attaching listeners.");
                    attachImeListeners(textarea);
                } else if (retries > 0) {
                    console.warn(`IME: Textarea not found, retrying... (${retries})`);
                    setTimeout(() => waitForTextarea(retries - 1), 100);
                } else {
                    console.error("IME: Failed to find xterm textarea. IME handling may be broken.");
                }
            }

            function attachImeListeners(textarea) {
                // Disable autocorrect and spellcheck to prevent double-input in Telex
                textarea.setAttribute('autocorrect', 'off');
                textarea.setAttribute('autocapitalize', 'none');
                textarea.setAttribute('spellcheck', 'false');
                textarea.setAttribute('inputmode', 'text');

                // Manual Context Injection for IME:
                textarea.addEventListener('compositionstart', () => {
                    console.log("IME: compositionstart");
                    isComposing = true;
                    if (term && term.buffer.active) {
                        const buffer = term.buffer.active;
                        const cursorY = buffer.cursorY + buffer.viewportY;
                        const line = buffer.getLine(cursorY);
                        if (line) {
                            const cursorX = buffer.cursorX;
                            // Get the text before the cursor
                            const text = line.translateToString(true).substring(0, cursorX);
                            // Only inject if the textarea is empty
                            if (text && textarea.value === '') {
                                textarea.value = text;
                                textarea.setSelectionRange(text.length, text.length);
                            }
                        }
                    }
                });

                textarea.addEventListener('compositionend', () => {
                    console.log("IME: compositionend");
                    isComposing = false;
                    // Force a small delay to ensure any pending 'input' events processed by xterm
                    // are also blocked or handled correctly if they arrive out of order.
                    setTimeout(() => { isComposing = false; }, 10);
                });
            }

            waitForTextarea();

            if (requestedRenderer === 'dom') {
                console.log("Forcing DOM renderer");
            } else if (requestedRenderer === 'canvas') {
                if (supportsCanvas()) enableCanvas();
                else console.log("Canvas not supported, using DOM");
            } else if (requestedRenderer === 'webgl') {
                if (supportsWebgl()) enableWebgl();
                else if (supportsCanvas()) enableCanvas();
                else console.log("WebGL/Canvas not supported, using DOM");
            } else {
                // Default: Try WebGL -> Canvas -> DOM
                if (supportsWebgl() && enableWebgl()) {
                    // Succeeded
                } else if (supportsCanvas() && enableCanvas()) {
                    // Succeeded
                } else {
                    console.log("Using standard DOM renderer");
                }
            }
            
            // Đảm bảo terminal chiếm toàn bộ không gian
            const doFit = () => {
                if (!term || !fitAddon || isSyncingSize) return;
                const container = document.getElementById('terminal');
                if (!container || !container.offsetParent || container.clientWidth === 0) return;

                try { 
                    // Thực hiện fit thực tế để khởi tạo kích thước ban đầu phù hợp với viewport
                    fitAddon.fit(); 
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({ type: 'Resize', data: { rows: term.rows, cols: term.cols } }));
                    }
                } catch(e) {
                    setTimeout(doFit, 100);
                }
            };

            setTimeout(doFit, 50);
            setTimeout(doFit, 300);

            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${window.location.host}/ws/${id}`);
            window.ws = ws;
            ws.binaryType = 'arraybuffer';

            ws.onopen = () => { doFit(); };
            ws.onmessage = (e) => { 
                if (typeof e.data === 'string') {
                    try {
                        const msg = JSON.parse(e.data);
                        if (msg.type === 'Exit') {
                            backToDashboard();
                        } else if (msg.type === 'SetSize') {
                            const { rows, cols } = msg.data;
                            if (term && (term.rows !== rows || term.cols !== cols)) {
                                console.log(`Syncing terminal size to ${cols}x${rows}`);
                                isSyncingSize = true;
                                term.resize(cols, rows);
                                
                                // Cập nhật kích thước vật lý của div terminal để hiện scrollbar nếu cần
                                const updatePhysicalSize = () => {
                                    if (term._core && term._core._renderService && term._core._renderService.dimensions.actualCellWidth > 0) {
                                        const dims = term._core._renderService.dimensions;
                                        const terminalEl = document.getElementById('terminal');
                                        terminalEl.style.setProperty('width', `${Math.ceil(cols * dims.actualCellWidth) + 10}px`, 'important');
                                        terminalEl.style.setProperty('height', `${Math.ceil(rows * dims.actualCellHeight) + 10}px`, 'important');
                                        terminalEl.style.minWidth = terminalEl.style.width;
                                        terminalEl.style.minHeight = terminalEl.style.height;
                                    } else {
                                        setTimeout(updatePhysicalSize, 50);
                                    }
                                };
                                updatePhysicalSize();

                                setTimeout(() => { isSyncingSize = false; }, 100);
                            }
                        }
                    } catch(err) { console.error("Parse signal error", err); }
                } else {
                    term.write(new Uint8Array(e.data)); 
                }
            };

            // Tự động cuộn theo con trỏ trên mobile khi terminal buffer lớn hơn màn hình
            if (isMobile) {
                term.onCursorMove(() => {
                    const cursorElement = container.querySelector('.xterm-cursor-layer');
                    if (cursorElement && term._core && term._core._renderService) {
                        const dims = term._core._renderService.dimensions;
                        const scrollLeft = term.buffer.active.cursorX * dims.actualCellWidth;
                        const scrollTop = (term.buffer.active.cursorY + term.buffer.active.viewportY) * dims.actualCellHeight;
                        
                        // Nếu con trỏ ra ngoài vùng nhìn thấy, cuộn container
                        const view = document.getElementById('terminal-view');
                        const buffer = 50; // Khoảng cách đệm
                        
                        if (scrollLeft < view.scrollLeft || scrollLeft > view.scrollLeft + view.clientWidth - buffer) {
                            view.scrollTo({ left: Math.max(0, scrollLeft - view.clientWidth / 2), behavior: 'smooth' });
                        }
                        if (scrollTop < view.scrollTop || scrollTop > view.scrollTop + view.clientHeight - buffer) {
                            view.scrollTo({ top: Math.max(0, scrollTop - view.clientHeight / 2), behavior: 'smooth' });
                        }
                    }
                });
            }
            ws.onerror = (err) => { console.error("WS Error", err); };
            ws.onclose = () => { 
                console.log("Session connection closed");
                // Optional: If connection closed WITHOUT an Exit signal, it might be a network error
                // We could show a "Reconnecting" UI here, but for now we'll just stay on the screen
                // or redirect if the server is gone.
            };
            
            term.onData(data => {
                // Block sending data while IME is composing (prevents double chars on mobile)
                if (isComposing) return;

                if (ws && ws.readyState === WebSocket.OPEN) {
                    let finalData = data;
                    
                    if (ctrlActive && data.length === 1) {
                        const code = data.charCodeAt(0);
                        if (code >= 97 && code <= 122) { // a-z
                            finalData = String.fromCharCode(code - 96);
                        } else if (code >= 65 && code <= 90) { // A-Z
                            finalData = String.fromCharCode(code - 64);
                        }
                        ctrlActive = false;
                        updateModifierUI();
                    } else if (altActive && data.length === 1) {
                        finalData = '\x1b' + data;
                        altActive = false;
                        updateModifierUI();
                    }

                    ws.send(JSON.stringify({ type: 'Input', data: finalData }));
                }
            });

            resizeObserver.observe(view);
            term.focus();
            
            // Cập nhật vị trí ngay lập tức cho mobile
            if (window.visualViewport) updateVisualViewport();
        }

        function updateModifierUI() {
            const ctrlBtn = document.getElementById('btn-ctrl-key');
            const altBtn = document.getElementById('btn-alt-key');
            if (ctrlBtn) {
                ctrlBtn.style.backgroundColor = ctrlActive ? '#3b82f6' : '#334155';
                ctrlBtn.setAttribute('data-active', ctrlActive);
            }
            if (altBtn) {
                altBtn.style.backgroundColor = altActive ? '#3b82f6' : '#334155';
                altBtn.setAttribute('data-active', altActive);
            }
        }

        function sendSpecialKey(key) {
            let data;
            switch (key) {
                case 'control': 
                    ctrlActive = !ctrlActive;
                    altActive = false;
                    updateModifierUI();
                    return;
                case 'alt': 
                    altActive = !altActive;
                    ctrlActive = false;
                    updateModifierUI();
                    return;
                case 'escape': data = '\x1b'; break;
                case 'tab': data = '\t'; break;
                case 'slash': data = '/'; break;
                case 'minus': data = '-'; break;
                case 'home': data = '\x1b[H'; break;
                case 'end': data = '\x1b[F'; break;
                case 'pageup': data = '\x1b[5~'; break;
                case 'pagedown': data = '\x1b[6~'; break;
                case 'arrowup': data = '\x1b[A'; break;
                case 'arrowdown': data = '\x1b[B'; break;
                case 'arrowleft': data = '\x1b[D'; break;
                case 'arrowright': data = '\x1b[C'; break;
            }
            if (data && ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'Input', data: data }));
            }
            if (term) term.focus();
        }

        function backToDashboard() {
            if (ws) { ws.close(); ws = null; }
            resizeObserver.disconnect();
            document.getElementById('dashboard').classList.remove('hidden');
            document.getElementById('terminal-view').style.display = 'none';
            document.getElementById('session-info').classList.add('hidden');
            document.getElementById('control-bar').style.display = 'none';
            document.getElementById('control-bar').style.transform = 'none';
            
            // Wait a tiny bit for backend cleanup to finish before refreshing
            setTimeout(fetchSessions, 100);
        }

        function initEventSource() {
            const es = new EventSource('/api/events');
            es.onmessage = (e) => {
                try {
                    const event = JSON.parse(e.data);
                    console.log("Real-time event:", event);
                    // Refresh session list for any creation or deletion event
                    fetchSessions();
                    
                    // If we are currently in a session that was deleted, go back to dashboard
                    const currentId = document.getElementById('current-session-id').innerText;
                    if (event.type === 'SessionDeleted' && event.data === currentId) {
                        alert(`Session "${currentId}" has been deleted.`);
                        backToDashboard();
                    }
                } catch (err) {
                    console.error("SSE parse error", err);
                }
            };
            es.onerror = () => {
                console.warn("SSE connection lost. Reconnecting...");
            };
        }

        fetchSessions();
        initEventSource();
    </script>
</body>
</html>
